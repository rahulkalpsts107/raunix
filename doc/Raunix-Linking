This Document will cover how this program is loaded with details about each segment addresses:

Linking(ld) is probably the last process of compilation where all symbol references are resolved and memory location is defined
for process execution.

The input to linker is nothing but object files generated by compiler. object files in linux end with .o extension.
object files are relocatable but they are bits and pieces of what make up a program in execution.
object files cannot be loaded into RAM for execution because a process would require all objects around it to be in a file with 
all symbols resolved in order to perform execution.

object files are always created in a format called object file format. In linux they can be in COFF or ELF .
Object files have a header that describe a magic number corresponding to a object file format.

However Linker does not really need to do this since Linkers job is to resolve symbols , perform relocation , and combine to produce object file.
So linker uses general purpose BFD libraries to operate on object files. It allows linker to read ,combine and write object files
in any format.

Check out this link shows how BFD works : http://www.scoberlin.de/content/media/http/informatik/gcc_docs/ld_5.html#SEC53

Linker uses BFD Libraries to operate on the canonical form and forming symbol tables.
While creating the output file the linker sends the canonical form which is converted to symbol table form and generated
into output file by BFD.

While Linking a linker script can be provided to force linker to organize sections in a way required rather than default way.
This is achieved here by linker.ld file

This command in Makefile here sets the Linker to pull this file while performing Linking.
	"LDFLAGS=-T core/linker.ld"

Picked up from doc
-T scriptfile
--script=scriptfile
Use scriptfile as the linker script. This script replaces ld's default linker script (rather than adding to it)

Each syntax is explained below from linker.ld.

TODO: Has to be updated as the linker.ld undergoes changes

TODO: Aun Ali has to mention the use of 0x100000 and 0xC0000000 VMA in the output description and significance?

OUTPUT_FORMAT("elf32-i386") /*The desired format of the output file generated by ld (linker)*/
OUTPUT_ARCH(i386) /*To specify a particular machine architecture*/

ENTRY(start) /*Setting the entry point , this will be the first instruction to be executed*/

/*SECTIONS is called a command to setup bss , data ,code and various other segments*/

/* use this "objdump -t raunix.bin " to check the address assignment for verification*/
SECTIONS
{
        . = 0x100000; /*Load this program beginning from this address . Change location counter '.' to 0x100000*/

        .setup : /* LMA =VMA */
        {
                *(.setup) /* * wildcard setup means place all setup input sections from different \
				input modules starting from this '.' adddress*/
        }

        . += 0xC0000000; /* incr address 0x100000 + sizeof(.setup) + 0xC0000000*/

        .text : AT(ADDR(.text) - 0xC0000000) /* output section name .text stored at VMA of "." aligned on strictest boundary by LD */
        {
                *(.text)
        }

        .data ALIGN (4096) : AT(ADDR(.data) - 0xC0000000) /* output section stored at VMA "."aligned on 4k boundary */
        {
                *(.data)
                *(.rodata*) /* rodata is a section containing strings which is moved to data segment in output file */
        } 

        .bss ALIGN (4096) : AT(ADDR(.bss) - 0xC0000000)
        {
                *(COMMON*) /* Some input object files contain common sections so it can be put into bss segment */
                *(.bss*)
        }
}


